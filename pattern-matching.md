# 模式匹配：解构，switch，if 表达式

> 在本章中，我们看看与模式匹配有关的三个特征：解构，`switch` 和 `if` 表达式。

### 离题：元组

为了说明模式和模式匹配，我们将使用元组。元组基本上是由位置（而不是名称）标识部分的记录。元组的部分称为组件。

让我们在 rtop 中创建一个元组：

```ocaml
# (true, "abc");
- : (bool, string) = (true, "abc")
```

这个元组的第一个元素是布尔值 true，第二个元素是字符串 “abc”。因此，元组的类型是（bool，string）。

让我们创建更多元组：

```ocaml
# (1.8, 5, ('a', 'b'));
- : (float, int, (char, char)) = (1.8, 5, ('a', 'b'))
```

### 模式匹配

在我们研究解构之前，`switch` 和 `if` 我们需要学习他们的基础：模式匹配。

模式是一种帮助处理数据的编程机制。它们有两个目的：

* 检查有什么结构的数据。
* 提取部分数据。

这是通过将数据与模式匹配来完成的。在语法上，模式的工作原理如下：

* ReasonML 具有创建数据的语法。例如：元组通过用逗号分隔数据并将结果放在括号中来创建。
* ReasonML 具有处理数据的语法。模式的语法反映了创建数据的语法。

我们从支持元组的简单模式开始。他们有以下语法：

* 一个变量名称就是一个模式。
  * 例如：`x`,`y`,`foo`。
* 文字是一种模式。
  * 例如：`123`,`"abc"`,`true`。
* 一组元组模式是一种模式。
  * 例如：`(8, x)`,`(3.2, "abc", true)`,`(1, (9, foo))

相同的变量名称不能在两个不同的位置使用。也就是说，以下模式是非法的：`(x, x)`。

#### 相等检查

最简单的模式没有任何变量。匹配这种模式基本上与平等检查相同。我们来看几个例子：

| 模式             |      数据       | 是否匹配 |
| ---------------- | :-------------: | -------: |
| 3                |        3        |       是 |
| (true, 12, 'p')  | (true, 12, 'p') |       是 |
| (false, 12, 'p') | (true, 12, 'p') |       否 |

到目前为止，我们已经使用该模式来确保数据具有预期的结构。作为下一步，我们引入变量名称。这些使结构检查更加灵活，让我们提取数据。

#### 模式中的变量名称

变量名称与其位置上的任何数据匹配，并导致创建绑定到该数据的变量。

| 模式   |  数据  | 是否匹配 |     变量绑定 |
| ------ | :----: | -------: | -----------: |
| x      |   3    |       是 |        x = 3 |
| (x, y) | (1, 4) |       是 | x = 1, y = 4 |
| (1, y) | (1, 4) |       是 |        y = 4 |
| (2, y) | (1, 4) |       否 |              |

特殊变量名称 `_` 不会创建变量绑定，可以多次使用：

| 模式    |  数据  | 是否匹配 | 变量绑定 |
| ------- | :----: | -------: | -------: |
| (x, _) | (1, 4) |       是 |    x = 1 |
| (1, _) | (1, 4) |       是 |          |
| (_, _)  | (1, 4) |       是 |          |
