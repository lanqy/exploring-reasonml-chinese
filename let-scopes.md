# let 绑定与作用域

>在本章中，我们将着眼于如何在 ReasonML 中引入新的变量和范围。

### 普通的 let 绑定

变量定义如下：

```ocaml
# let x = 123;
let x: int = 123;
# x;
- : int = 123
```

以这种方式创建的每个绑定(变量-值对)都是不可变的——您不能为变量分配一个不同的值。规范是为了使值也是不可变的，但不一定非得如此。

由于绑定是不可变的，所以必须立即初始化变量。你不能让它未初始化。

### 重新定义变量

ReasonML不会阻止您重新定义变量：

```ocaml
# let x = 1;
let x: int = 1;
# x;
- : int = 1
# let x = 2;
let x: int = 2;
# x;
- : int = 2
```

这与绑定的不可变性没有冲突：它更像嵌套作用域中的阴影，而不像改变变量的值。

能够重新定义变量在交互式命令行中特别有用。

### 类型注解

您还可以使用类型注释变量:

```ocaml
# let y: string = "abc";
let y: string = "abc";
```

对于更复杂的类型，声明类型有时是必需的，但对于简单的类型则是多余的。

### 通过作用域块创建新的作用域

变量的作用域是它存在的语法结构。块使您能够引入新的作用域。它们以大括号（{}）开头和结尾：

```ocaml
let x = "hello";
print_string(x); /* hello */
{ /* A */
    let x = "tmp";
    print_string(x) /* tmp */
}; /* B */
print_string(x); /* hello */
```

该块从 A 行开始，并在 B 行结束。

块的内部与文件的顶层具有相同的结构：它是用分号分隔的一系列表达式。

为什么在 B 行结束大括号之后有分号？块是另一种表达。它的值是它内部最后一个表达式的值。这意味着您可以将代码块放在任何可以放置表达式的地方：

```ocaml
let x = { print_string("hi"); 123}; /* hi */
print_int(x); /* 123 */ 
```

另外一个例子：

```ocaml
print_string({
    let s = "ma";
    s ++ s;
}); /* mama */
```

这在 ReasonML 中延续了一个共同的主题：大部分东西都是表达式。